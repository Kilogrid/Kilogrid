// IMPORTANT NOTES:
// SENDING TO MUCH WILL BLOCK THE CAN AND YOU CANNOT SEND ANY CONTROL MESSAGES ANYMORE!!!!!


#include <avr/io.h>
#include <avr/wdt.h>
#include <util/delay.h>     // delay macros
#include <avr/interrupt.h>
#include <math.h>

#include "module.h"
#include "moduleLED.h"
#include "moduleIR.h"
#include "CAN.h"
#include "mcp2515.h"

#include "../communication.h"

volatile uint8_t cell_x[4] = {0, 0, 0, 0};
volatile uint8_t cell_y[4] = {0, 0, 0, 0};
volatile uint8_t cell_role[4] = {0, 0, 0, 0};
volatile uint8_t cell_colour[4] = {0, 0, 0, 0};

volatile uint8_t cell_received_op[4] = {0, 0, 0, 0};


uint8_t send = 0;
uint8_t receive = 10;
uint8_t send_success = 0;
uint32_t broadcast_timer = 0;

uint8_t received_com_range = 0;
uint8_t received_option = 0;
uint8_t received_x = 0;
uint8_t received_y = 0;

uint8_t com_range = 0;
uint8_t option = 0;
uint8_t my_x = 0;
uint8_t my_y = 0;


cell_num_t cell_id[4] = {CELL_00, CELL_01, CELL_02, CELL_03};

IR_message_t IR_message_tx[4];
IR_message_t IR_msg_rx;

tracking_user_data_t tracking_data;


// TODO cell2module
// TODO module2cell



void IR_rx(IR_message_t *m, cell_num_t c, distance_measurement_t *d, uint8_t CRC_error) {
    if(!CRC_error && m->type == TRACKING){
        CAN_message_t* msg = next_CAN_message();
        if(msg != NULL) { // if the buffer is not full
            serialize_tracking_message(msg, c, m->data);
        }
    }else if(!CRC_error && m->type == 62){  // TODO 62 is hopefully free 
        received_option = m->data[0];
        received_com_range = m->data[1];
        received_x = m->data[2];
        received_y = m->data[3];

        //receive = 1;
        if(received_y % 2 == 1 && received_x % 2 == 0){
            receive = 0;   
        }else if(received_y % 2 == 1 && received_x % 2 == 1){
            receive = 1;   
        }else if(received_y % 2 == 0 && received_x % 2 == 0){
            receive = 2;    
        }else if(received_y % 2 == 0 && received_x % 2 == 1){
            receive = 3;    
        }
    }
}

void CAN_rx(CAN_message_t *m) { 
    if (m->data[0]== 55){
        cell_received_op[0] = m->data[1];
        cell_received_op[1] = m->data[2];
        cell_received_op[2] = m->data[3];
        cell_received_op[3] = m->data[4];
    }
}

void CAN_tx_success(){
    send_success = 1;
    return;
}

void setup(){
    cell_x[0] = (configuration[0] * 2);
    cell_x[1] = (configuration[0] * 2 + 1);
    cell_x[2] = (configuration[0] * 2);
    cell_x[3] = (configuration[0] * 2 + 1);

    cell_y[0] = (configuration[1] * 2 + 1);
    cell_y[1] = (configuration[1] * 2 + 1);
    cell_y[2] = (configuration[1] * 2);
    cell_y[3] = (configuration[1] * 2);

    cell_role[0] = (configuration[2]);
    cell_role[1] = (configuration[2]);
    cell_role[2] = (configuration[2]);
    cell_role[3] = (configuration[2]);

    cell_colour[0] = (configuration[3]);
    cell_colour[1] = (configuration[4]);
    cell_colour[2] = (configuration[5]);
    cell_colour[3] = (configuration[6]);

}


void loop(){
    
	for(int i = 0; i < 4; ++i){

        IR_message_tx[i].type = 1;
        IR_message_tx[i].data[0] = cell_x[i];
        IR_message_tx[i].data[1] = cell_y[i];
        IR_message_tx[i].data[2] = cell_role[i];
        IR_message_tx[i].data[3] = cell_colour[i];  // this should be the option .. 1,2,3 or 0 if wall?!?

        set_IR_message(&IR_message_tx[i], i);

        // set inital colours for the grid 
        if(receive == i){
            set_LED_with_brightness(cell_id[i], YELLOW, HIGH);
        }else{
            switch(cell_received_op[i]){
                case 0:
                    // this is wall
                    set_LED_with_brightness(cell_id[i], GREEN, HIGH);
                case 1:
                    // option 1
                    set_LED_with_brightness(cell_id[i], RED, HIGH);
                    break;
                case 2:
                    // option 2
                    set_LED_with_brightness(cell_id[i], GREEN, HIGH);
                    break;
                case 3:
                    // option 3 
                    set_LED_with_brightness(cell_id[i], BLUE, HIGH);
                    break;
                default:
                    break;
            }
        }


        
        com_range = received_com_range;
        option = received_option;
        my_x = received_x;
        my_y = received_y;
        broadcast_timer += 1;

        if (cell_x[i] == 10 && cell_y[i] == 10 && send_success == 0 && send == 0){
        	send = 1;

        	CAN_message_t test_message;
        	init_CAN_message(&test_message);
        	test_message.id = 55;
        	test_message.data[0] = 55;
        	for (int cell_it = 0; cell_it < 4; cell_it++){
                test_message.data[cell_it + 1] = 1; // set if broadcast to cell cell_i           
            }

            kilogrid_address_t test_dest;
            test_dest.type = ADDR_INDIVIDUAL; // see communication/kilogrid.h for further information
            test_dest.x = 1;  // is the position of a module imo??
            test_dest.y = 1;

            send_success = CAN_message_tx(&test_message, test_dest); // CAN_message_t *message, kilogrid_address_t dest 
            _delay_ms(10);
        }

/*
        if (cell_x[i] == my_x && cell_y[i] == my_y && cell_x[i] != 0 && cell_y[i] != 0 && receive < 4 && broadcast_timer > 50){
            receive = 10;
            broadcast_timer = 0;
        

        
            // init sending grid
            uint8_t grid[20][40][4];
            for(int i = 0; i < 20; i++){
                for(int k = 0; k < 40; k++){
                    for(int l = 0; l < 4; l++){
                        grid[i][k][l] = 0;
                    }
                }
            }

            //TODO check if this work
            // calculate receiving cells
            for(int x_it = my_x - com_range; x_it <= my_x + com_range; x_it++){
                for (int y_it = my_y - com_range; y_it <= my_y + com_range; y_it++){
                    // check borders
                    if(x_it >= 0 && x_it < 20 && y_it >= 0 && y_it < 40){
                        // check distance -> use L2/euclidean norm!
                        if(sqrt(pow(fabs(x_it-my_x),2) + pow(fabs(y_it-my_y),2)) < com_range){
                            // which cells do we have to address
                            if(y_it % 2 == 1 && x_it % 2 == 0){
                                grid[x_it/2][y_it/2][0] = received_option;    
                            }else if(y_it % 2 == 1 && x_it % 2 == 1){
                                grid[x_it/2][y_it/2][1] = received_option;    
                            }else if(y_it % 2 == 0 && x_it % 2 == 0){
                                grid[x_it/2][y_it/2][2] = received_option;    
                            }else if(y_it % 2 == 0 && x_it % 2 == 1){
                                grid[x_it/2][y_it/2][3] = received_option;    
                            }
                        }
                    }
                }
            }

        
            // iterate through all cells - to check if we need to send a msg to this cell
            // TODO only loop through close by modules 
            for(int x_it = 0; x_it < 10; x_it++){
                for(int y_it = 0; y_it < 20; y_it++){
                    // pack msg only send if it needs to be
                    uint8_t send_flag = 0;

                     CAN_message_t test_message;  // for structure of a can msg see communication/mcp2515.h

                    init_CAN_message(&test_message);

                    test_message.id = 55;  // dont know if id is important - maybe to check if msg arrived twice or so - max 65,535
                    test_message.data[0] = 55; // maybe this is the msg type (must be larger than 25 to dont overwrite something and less than 64 see communication/CAN.h)
                    for (int cell_it = 0; cell_it < 4; cell_it++){
                        test_message.data[cell_it + 1] = grid[x_it][y_it][cell_it]; // set if broadcast to cell cell_it
                        if(grid[x_it][y_it][cell_it] != 0){
                            send_flag = 1;
                        }
                    }

                    kilogrid_address_t test_dest;
                    test_dest.type = ADDR_INDIVIDUAL; // see communication/kilogrid.h for further information
                    test_dest.x = x_it;  // is the position of a module imo??
                    test_dest.y = y_it;

                    if(send_flag == 1){
                        CAN_message_tx(&test_message, test_dest); // CAN_message_t *message, kilogrid_address_t dest 
                        _delay_ms(10);
                    }
                }
            }   
        }
        */
	}
}


int main() {
    module_init();

    // register function callbacks
    module_CAN_message_rx = CAN_rx;

    //module_CAN_message_tx_success = CAN_message_tx_success_my;
    module_CAN_message_tx_success = CAN_tx_success;  // seems not to work

    module_IR_message_rx = IR_rx;

    module_start(setup, loop);

    return 0;
}
